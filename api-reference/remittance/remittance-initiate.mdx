---

title: "Initiate Remittance"
description: "Create a remittance request"
openapi: "POST /payments-api-service/v1/remittance"

---

[//]: # ()
[//]: # (<Note>)

[//]: # (    <strong>Idempotency:</strong> Reuse the same <code>transaction.reference</code> to safely retry the same request.)

[//]: # (</Note>)

[//]: # ()
[//]: # (## Prerequisites)

[//]: # ()
[//]: # (- **Bearer token** from `POST /authentication-service/v1/api/generate-token`)

[//]: # (- **Signature header** `X-Custom-Signature` &#40;RS256 over the concatenation below&#41;)

[//]: # (- **Public key** registered with Waftpay &#40;your private key stays on your server&#41;)

[//]: # ()
[//]: # (**Signing string &#40;no separators&#41;:**)


<Note>
    <strong>Idempotency:</strong> Reuse the same <code>transaction.reference</code> to safely retry the same request.
</Note>

## Prerequisites

- **Bearer token** from `POST /authentication-service/v1/api/generate-token`
- **Signature header** `X-Custom-Signature` (RS256 over the concatenation below)
- **Public key** registered with Waftpay (your private key stays on your server)

**Signing string (no separators):**
```
transaction.reference + transaction.amount + originator.country + recipient.service_code
```

<Info>
    See <strong>X-Custom-Signature</strong> for key generation, signing examples, and local verification.
</Info>

<Warning>
    <strong>Timestamp format:</strong> If your tenant enforces ISO-8601, use <code>2025-01-21T12:30:10Z</code>. Otherwise, the examples here use <code>YYYY-MM-DD HH:mm:ss</code> (e.g., <code>2025-01-21 12:30:10</code>). Match your tenant configuration.
</Warning>

---

## Required headers

```http
Authorization: Bearer <token>
X-Custom-Signature: <base64-rsa-sha256-signature>
Content-Type: application/json
```

---

## Example request

```json
{
  "transaction": {
    "reference": "TXN123654573",
    "amount": 100,
    "currency": "KES",
    "description": "Test",
    "timestamp": "2025-01-21 12:30:10"
  },
  "originator": {
    "msisdn": "254722111999",
    "channel": "Test",
    "country": "KEN",
    "Service_provider": "TELCOM-UK",
    "name": "John Sender",
    "dob": "1965-01-01",
    "nationality": "UK",
    "id_type": "Passport"
  },
  "recipient": {
    "service_code": "ewqeqw",
    "reference": "Test",
    "account": "Test",
    "name": "John Doe Init"
  },
  "callback_url": "https://www.google.com",
  "meta": {
    "note": "Test",
    "agent_id": "Test"
  }
}
```

---

## cURL

```bash
curl --request POST   --url https://sandbox.waftpay.io/api/payments-api-service/v1/remittance   --header "Authorization: Bearer <token>"   --header "X-Custom-Signature: <base64-rsa-sha256-signature>"   --header "Content-Type: application/json"   --data '{
    "transaction": {
      "reference": "TXN123654573",
      "amount": 100,
      "currency": "KES",
      "description": "Test",
      "timestamp": "2025-01-21 12:30:10"
    },
    "originator": {
      "msisdn": "254722111999",
      "channel": "Test",
      "country": "KEN",
      "Service_provider": "TELCOM-UK",
      "name": "John Sender",
      "dob": "1965-01-01",
      "nationality": "UK",
      "id_type": "Passport"
    },
    "recipient": {
      "service_code": "ewqeqw",
      "reference": "Test",
      "account": "Test",
      "name": "John Doe Init"
    },
    "callback_url": "https://www.google.com",
    "meta": {
      "note": "Test",
      "agent_id": "Test"
    }
  }'
```

## Remittance Request — Process Flow (end-to-end)

This section documents the complete server flow so you can integrate and debug confidently.

### Step-by-step detail

#### Step 1: Incoming Request
- **Endpoint:** `POST /payments-api-service/v1/remittance`
- **Headers:** `Authorization: Bearer <JWT>`, `X-Custom-Signature: <base64>`
- **Body:** Valid JSON matching the Remittance schema

#### Step 2: `doFilterInternal` — Authentication & Authorization Filter
- **Skip check:** Allows Swagger, actuator, and documentation routes to pass unfiltered.
- **Authorization header validation:**
- Must be present and start with **`Bearer `**.
- If missing/invalid → **401 Unauthorized**.
- **JWT token parsing:** Parse and extract claims; build **ClientDetails** (client/product/entitlements).
- **Service code authorization:**
- Read `recipient.service_code` from request body.
- Verify client is entitled to that service.
- If unauthorized → **persist invalid request** for audit and return **403 Forbidden**.
- **Session data setup:** Populate ThreadLocal `SessionData` with `clientId`, `productId`, `serviceCode`, `signature` (raw header), for downstream access.

#### Step 3: Controller (`RemittanceController`)
- **Endpoint:** `POST /payments-api-service/v1/remittance`
- **Validation:** `@Validated(RemittanceRequest.ValidateRequest.class)` on body.
- **Delegation:** Calls `remittanceService.processRemittanceRequest(...)`.

#### Step 4: Business Logic in `processRemittanceRequest(...)`
- **Signature validation:**
- Construct the data string:
```
transaction.reference + transaction.amount + originator.country + recipient.service_code
    ```
- Use `publicKeyService` to verify `X-Custom-Signature` (RSA-2048 + SHA-256, PKCS#1 v1.5).
- If invalid → **persist as BAD_REQUEST** and map `SignatureVerificationException` to **400 Bad Request**.
- **Save request for processing:**
- `paymentService.savePaymentRequest(...)` and mark state **ACCEPTED**.
- **Publish request for processing:**
- Build a `PaymentAPIRequest` containing required metadata and the original payload.
- Publish to **RabbitMQ** queue **`PAYMENTS.ROUTING.QUEUE`** (durable; DLQ recommended).

**Sample published message**

```json
{
  "amount": 1000,
  "client_id": 1,
  "service_code": "MPESAB2C",
  "payment_uuid": 109091010100010001010,
  "client_reference": "ref-115139914",
  "account": "254712345678",
  "payload": {
    "transaction": {
      "reference": "ref-115139914",
      "amount": 1000,
      "currency": "KES",
      "description": "Test description",
      "timestamp": "2025-01-21 12:30:10"
    },
    "originator": {
      "msisdn": "254712345678",
      "channel": "USSD",
      "country": "KE",
      "name": "254712345678",
      "purpose": "Collections"
    },
    "recipient": {
      "service_code": "MPESAB2C",
      "pay_bill_number": "600987",
      "store_number": "600987",
      "reference": "INVJMA01",
      "account": "254712345678"
    },
    "callback_url": "https://www.google.com",
    "meta_data": {
      "note": "This info is returned as part of the callback",
      "agent_id": "AGENT456"
    }
  }
}
```

#### Step 5: Response Handling in Filter
- Intercepts and reads the response body.
- Parses into `APIResponse`.
- If `description` **starts with "Field..."** (field-level validation errors):
- **Re-save** the original request as **BAD_REQUEST**.
- Respond with the error message and **400** status.
- If everything is valid: **pass through** the controller’s response to the client.

---

## Successful response (example)

```json
{
  "status": "200.100",
  "code": "ACCEPTED",
  "description": "Accepted for processing",
  "data": {
    "amount": 100,
    "total_charges": 0,
    "total_amount": 100,
    "transaction_reference": "TXN123654573",
    "payment_uuid": "8363546214883574601",
    "payment_reference": "1RJITP5HLL",
    "time_received": "2025-04-04T06:13:52.585619Z"
  }
}
```

---

## Common errors & fixes

- **401 Unauthorized** — Missing/invalid Bearer token. Ensure you’re using a valid token for the **Remittance** product.
- **403 Forbidden** — Client is not authorized for the given `recipient.service_code`. Confirm entitlements.
- **400 Bad Request** — Signature verification failed; field/timestamp validation errors; schema violations.
- **409 Conflict** — Duplicate `transaction.reference` (idempotency hit). Expect prior response shape.
- **5xx Internal** — Transient error; retry with the same idempotency key.

---

## Ops & reliability tips

- Use **durable** queues and a **DLQ** for `PAYMENTS.ROUTING.QUEUE`.
- Emit metrics: request rate, accept/reject counts, signature failures, DLQ depth, p95/p99 latency.
- Use **structured logging** with: `client_id`, `service_code`, `transaction.reference`, `payment_uuid`, and correlation IDs.
- Never log secrets, private keys, raw signatures, or full tokens (redact/hash sensitive values).

---

## Pre-flight checklist

- [ ] Bearer token for **Remittance** product (not Payouts/Collections)
- [ ] `X-Custom-Signature` computed over the correct field order (no separators)
- [ ] Payload values match what was signed (amount format, `originator.country` casing, `recipient.service_code`)
- [ ] `callback_url` is HTTPS and reachable
- [ ] `transaction.reference` is unique per logical request (idempotency)
