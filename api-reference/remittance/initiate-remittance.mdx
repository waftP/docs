---
title: "Initiate Remittance"
description: "Create a remittance request"
openapi: "POST /payments-api-service/v1/remittance"
---

<Note>
  <strong>Idempotency:</strong> Reuse the same <code>transaction.reference</code> to safely retry the same request.
</Note>

## Prerequisites

- **Bearer token** from `POST /authentication-service/v1/api/generate-token`
- **Signature header** `X-Custom-Signature` (RS256 over the concatenation below)
- **Public key** registered with Waftpay (your private key stays on your server)

**Signing string (no separators):**
```
transaction.reference + transaction.amount + originator.country + recipient.service_code
```

<Info>
See <strong>X-Custom-Signature</strong> for key generation, signing examples, and local verification.
</Info>

<Warning>
<strong>Timestamp format:</strong> ISO-8601, use <code>2025-01-21T12:30:10Z</code>.
</Warning>

---

## Required headers

```http
Authorization: Bearer <token>
X-Custom-Signature: <base64-rsa-sha256-signature>
Content-Type: application/json
```

---

## Example request

```json
{
  "transaction": {
    "reference": "TXN123654573",
    "amount": 100,
    "currency": "KES",
    "description": "Test",
    "timestamp": "2025-01-21 12:30:10"
  },
  "originator": {
    "msisdn": "254722111999",
    "channel": "Test",
    "country": "KEN",
    "Service_provider": "TELCOM-UK",
    "name": "John Sender",
    "dob": "1965-01-01",
    "nationality": "UK",
    "id_type": "Passport"
  },
  "recipient": {
    "service_code": "ewqeqw",
    "reference": "Test",
    "account": "Test",
    "name": "John Doe Init"
  },
  "callback_url": "https://www.google.com",
  "meta": {
    "note": "Test",
    "agent_id": "Test"
  }
}
```

---

## cURL

```bash
curl --request POST   --url https://sandbox.waftpay.io/api/payments-api-service/v1/remittance   --header "Authorization: Bearer <token>"   --header "X-Custom-Signature: <base64-rsa-sha256-signature>"   --header "Content-Type: application/json"   --data '{
    "transaction": {
      "reference": "TXN123654573",
      "amount": 100,
      "currency": "KES",
      "description": "Test",
      "timestamp": "2025-01-21 12:30:10"
    },
    "originator": {
      "msisdn": "254722111999",
      "channel": "Test",
      "country": "KEN",
      "Service_provider": "TELCOM-UK",
      "name": "John Sender",
      "dob": "1965-01-01",
      "nationality": "UK",
      "id_type": "Passport"
    },
    "recipient": {
      "service_code": "ewqeqw",
      "reference": "Test",
      "account": "Test",
      "name": "John Doe Init"
    },
    "callback_url": "https://www.google.com",
    "meta": {
      "note": "Test",
      "agent_id": "Test"
    }
  }'
```

---

## Generate `X-Custom-Signature`

**String to sign (example):** `TXN123654573100KENewqeqw`  
(Use your exact payload values and casing.)

<Tabs>
  <Tab title="Node.js">

```js
import crypto from "crypto";
import fs from "fs";

const txRef = "TXN123654573";
const amount = "100";   // stringify exactly as sent
const country = "KEN";  // match payload (KE vs KEN)
const service = "ewqeqw";

const signingString = `${txRef}${amount}${country}${service}`;
const privateKeyPem = fs.readFileSync("client_private.pem", "utf8");

const sig = crypto.sign("RSA-SHA256", Buffer.from(signingString, "utf8"), privateKeyPem);
console.log(sig.toString("base64")); // -> X-Custom-Signature
```
  </Tab>
  <Tab title="Python">

```python
import base64
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding

tx_ref = "TXN123654573"
amount = "100"
country = "KEN"
service = "ewqeqw"

signing_string = f"{tx_ref}{amount}{country}{service}".encode("utf-8")

with open("client_private.pem", "rb") as f:
    key = serialization.load_pem_private_key(f.read(), password=None)

sig = key.sign(signing_string, padding.PKCS1v15(), hashes.SHA256())
print(base64.b64encode(sig).decode("utf-8"))  # -> X-Custom-Signature
```
  </Tab>
  <Tab title="PHP">

```php
<?php
$signingString = "TXN123654573100KENewqeqw";
$privateKey = openssl_pkey_get_private(file_get_contents('client_private.pem'));
openssl_sign($signingString, $rawSig, $privateKey, OPENSSL_ALGO_SHA256);
echo base64_encode($rawSig), PHP_EOL; // -> X-Custom-Signature
```
  </Tab>
</Tabs>

<Note>
Use <em>standard Base64</em> (not Base64URL). Algorithm is <strong>RS256</strong> (RSA PKCS#1 v1.5 + SHA-256).
</Note>

---

## Remittance Request — Process Flow (end-to-end)

This section documents the complete server flow so you can integrate and debug confidently.

### High-level sequence

```mermaid
sequenceDiagram
  autonumber
  participant C as Client
  participant F as doFilterInternal (AuthN/Z)
  participant CTRL as RemittanceController
  participant SVC as RemittanceService
  participant MQP as MQ Publisher
  participant MQ as RabbitMQ
  participant DB as Persistence

  C->>F: POST /payments-api-service/v1/remittance (Bearer + X-Custom-Signature + JSON)
  F->>F: Allow swagger/actuator/doc routes to pass (skip)
  F->>F: Validate Authorization header (must start with "Bearer ")
  alt Missing/invalid
    F-->>C: 401 Unauthorized
  else Valid
    F->>F: Parse JWT, extract claims & ClientDetails
    F->>F: Read recipient.service_code from body
    F->>F: Check client is authorized for service_code
    alt Not authorized
      F->>DB: Persist invalid request (audit)
      F-->>C: 403 Forbidden
    else Authorized
      F->>F: Populate SessionData (clientId, productId, serviceCode, signature) in ThreadLocal
      F->>CTRL: Forward wrapped request
      CTRL->>SVC: processRemittanceRequest(payload)
      SVC->>SVC: Build signing string & verify via publicKeyService (RS256)
      alt Signature invalid
        SVC->>DB: Persist as BAD_REQUEST
        SVC-->>CTRL: SignatureVerificationException
        CTRL-->>C: 400 Bad Request
      else Signature OK
        SVC->>DB: paymentService.savePaymentRequest(..., state=ACCEPTED)
        SVC->>MQP: Build PaymentAPIRequest (metadata + payload)
        MQP->>MQ: Publish to PAYMENTS.ROUTING.QUEUE (durable)
        CTRL-->>C: 201/202 ACCEPTED (refs + timestamps)
      end
      F->>F: Intercept response; parse APIResponse
      alt description starts with "Field..."
        F->>DB: Re-save original as BAD_REQUEST
        F-->>C: 400 Validation error
      else
        F-->>C: Pass through response
      end
    end
  end
```

### Step-by-step detail

#### Step 1: Incoming Request
- **Endpoint:** `POST /payments-api-service/v1/remittance`
- **Headers:** `Authorization: Bearer <JWT>`, `X-Custom-Signature: <base64>`
- **Body:** Valid JSON matching the Remittance schema

#### Step 2: `doFilterInternal` — Authentication & Authorization Filter
- **Skip check:** Allows Swagger, actuator, and documentation routes to pass unfiltered.
- **Authorization header validation:**
  - Must be present and start with **`Bearer `**.
  - If missing/invalid → **401 Unauthorized**.
- **JWT token parsing:** Parse and extract claims; build **ClientDetails** (client/product/entitlements).
- **Service code authorization:**
  - Read `recipient.service_code` from request body.
  - Verify client is entitled to that service.
  - If unauthorized → **persist invalid request** for audit and return **403 Forbidden**.
- **Session data setup:** Populate ThreadLocal `SessionData` with `clientId`, `productId`, `serviceCode`, `signature` (raw header), for downstream access.

#### Step 3: Controller (`RemittanceController`)
- **Endpoint:** `POST /payments-api-service/v1/remittance`
- **Validation:** `@Validated(RemittanceRequest.ValidateRequest.class)` on body.
- **Delegation:** Calls `remittanceService.processRemittanceRequest(...)`.

#### Step 4: Business Logic in `processRemittanceRequest(...)`
- **Signature validation:**
  - Construct the data string:
    ```
    transaction.reference + transaction.amount + originator.country + recipient.service_code
    ```
  - Use `publicKeyService` to verify `X-Custom-Signature` (RSA-2048 + SHA-256, PKCS#1 v1.5).
  - If invalid → **persist as BAD_REQUEST** and map `SignatureVerificationException` to **400 Bad Request**.
- **Save request for processing:**
  - `paymentService.savePaymentRequest(...)` and mark state **ACCEPTED**.
- **Publish request for processing:**
  - Build a `PaymentAPIRequest` containing required metadata and the original payload.
  - Publish to **RabbitMQ** queue **`PAYMENTS.ROUTING.QUEUE`** (durable; DLQ recommended).

**Sample published message**

```json
{
  "amount": 1000,
  "client_id": 1,
  "service_code": "MPESAB2C",
  "payment_uuid": 109091010100010001010,
  "client_reference": "ref-115139914",
  "account": "254712345678",
  "payload": {
    "transaction": {
      "reference": "ref-115139914",
      "amount": 1000,
      "currency": "KES",
      "description": "Test description",
      "timestamp": "2025-01-21 12:30:10"
    },
    "originator": {
      "msisdn": "254712345678",
      "channel": "USSD",
      "country": "KE",
      "name": "254712345678",
      "purpose": "Collections"
    },
    "recipient": {
      "service_code": "MPESAB2C",
      "pay_bill_number": "600987",
      "store_number": "600987",
      "reference": "INVJMA01",
      "account": "254712345678"
    },
    "callback_url": "https://www.google.com",
    "meta_data": {
      "note": "This info is returned as part of the callback",
      "agent_id": "AGENT456"
    }
  }
}
```

#### Step 5: Response Handling in Filter
- Intercepts and reads the response body.
- Parses into `APIResponse`.
- If `description` **starts with "Field..."** (field-level validation errors):
  - **Re-save** the original request as **BAD_REQUEST**.
  - Respond with the error message and **400** status.
- If everything is valid: **pass through** the controller’s response to the client.

---

## Successful response (example)

```json
{
  "status": "200.100",
  "code": "ACCEPTED",
  "description": "Accepted for processing",
  "data": {
    "amount": 100,
    "total_charges": 0,
    "total_amount": 100,
    "transaction_reference": "TXN123654573",
    "payment_uuid": "8363546214883574601",
    "payment_reference": "1RJITP5HLL",
    "time_received": "2025-04-04T06:13:52.585619Z"
  }
}
```

---

## Common errors & fixes

- **401 Unauthorized** — Missing/invalid Bearer token. Ensure you’re using a valid token for the **Remittance** product.  
- **403 Forbidden** — Client is not authorized for the given `recipient.service_code`. Confirm entitlements.  
- **400 Bad Request** — Signature verification failed; field/timestamp validation errors; schema violations.  
- **409 Conflict** — Duplicate `transaction.reference` (idempotency hit). Expect prior response shape.  
- **5xx Internal** — Transient error; retry with the same idempotency key.

---

## Ops & reliability tips

- Use **durable** queues and a **DLQ** for `PAYMENTS.ROUTING.QUEUE`.  
- Emit metrics: request rate, accept/reject counts, signature failures, DLQ depth, p95/p99 latency.  
- Use **structured logging** with: `client_id`, `service_code`, `transaction.reference`, `payment_uuid`, and correlation IDs.  
- Never log secrets, private keys, raw signatures, or full tokens (redact/hash sensitive values).

---

## Pre-flight checklist

- [ ] Bearer token for **Remittance** product (not Payouts/Collections)  
- [ ] `X-Custom-Signature` computed over the correct field order (no separators)  
- [ ] Payload values match what was signed (amount format, `originator.country` casing, `recipient.service_code`)  
- [ ] `callback_url` is HTTPS and reachable  
- [ ] `transaction.reference` is unique per logical request (idempotency)
