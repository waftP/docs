---
title: "Webhooks — Signature Verification"
description: "Verify that webhook notifications really came from Waftpay and weren’t tampered with."
---

# Webhooks — Signature Verification

Waftpay signs every webhook it sends to your `callback_url`. Verify the signature **before** trusting the payload.

> **Header format**
>
> `Waftpay-Signature: t=1700000100, v1=4b2f..., alg=hmac-sha256`
>
> - `t` — UNIX timestamp (seconds)
> - `v1` — hex HMAC signature
> - `alg` — algorithm indicator (currently `hmac-sha256`)

> **Best practice**: Reject requests older than 5 minutes or with a clock skew beyond your tolerance.

## Verification algorithm (HMAC-SHA256)

1. Read the header and parse `t`, `v1`, `alg`
2. Build the signed payload: `t + "." + raw_body` (bytes)
3. Compute `HMAC_SHA256(secret, signed_payload)` → hex
4. Use a constant-time compare with `v1`
5. Enforce a **freshness window** (e.g., ±300 seconds)

### Node.js

```js
import crypto from "node:crypto";

export function verifyWebhook({ secret, rawBody, signatureHeader }){
  const parts = Object.fromEntries(signatureHeader.split(",").map(s => s.trim().split("=")));
  const t = parseInt(parts.t, 10), v1 = parts.v1, alg = parts.alg;
  if (alg !== "hmac-sha256" || !t || !v1) return false;
  if (Math.abs(Math.floor(Date.now()/1000) - t) > 300) return false;
  const payload = Buffer.concat([Buffer.from(String(t)), Buffer.from("."), Buffer.from(rawBody)]);
  const mac = crypto.createHmac("sha256", Buffer.from(secret, "utf8")).update(payload).digest("hex");
  return crypto.timingSafeEqual(Buffer.from(mac, "hex"), Buffer.from(v1, "hex"));
}
```

### Python

```python
import hmac, hashlib, time

def verify_webhook(secret: bytes, raw_body: bytes, signature_header: str) -> bool:
  parts = dict(kv.strip().split("=",1) for kv in signature_header.split(","))
  t = int(parts.get("t","0")); v1 = parts.get("v1"); alg = parts.get("alg")
  if alg != "hmac-sha256" or not v1: return False
  if abs(int(time.time()) - t) > 300: return False
  mac = hmac.new(secret, f"{t}.".encode() + raw_body, hashlib.sha256).hexdigest()
  return hmac.compare_digest(mac, v1)
```

### Java

```java
import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec;
public static boolean verify(String secret, byte[] rawBody, String header) throws Exception {
  var parts = new java.util.HashMap<String,String>();
  for (var kv : header.split(",")) { var p = kv.trim().split("="); parts.put(p[0], p[1]); }
  long t = Long.parseLong(parts.getOrDefault("t","0"));
  String v1 = parts.get("v1"), alg = parts.get("alg");
  if (!"hmac-sha256".equals(alg) || v1 == null) return false;
  if (Math.abs(System.currentTimeMillis()/1000 - t) > 300) return false;
  var mac = Mac.getInstance("HmacSHA256");
  mac.init(new SecretKeySpec(secret.getBytes(java.nio.charset.StandardCharsets.UTF_8), "HmacSHA256"));
  byte[] pre = (t + ".").getBytes(java.nio.charset.StandardCharsets.UTF_8);
  byte[] data = new byte[pre.length + rawBody.length];
  System.arraycopy(pre, 0, data, 0, pre.length); System.arraycopy(rawBody, 0, data, pre.length, rawBody.length);
  String calc = javax.xml.bind.DatatypeConverter.printHexBinary(mac.doFinal(data)).toLowerCase();
  return java.security.MessageDigest.isEqual(calc.getBytes(), v1.getBytes());
}
```

### PHP

```php
<?php
function verifyWebhook(string $secret, string $rawBody, string $header): bool {
  $parts = [];
  foreach (explode(',', $header) as $kv) { [$k,$v] = array_map('trim', explode('=', $kv)); $parts[$k] = $v; }
  if (($parts['alg'] ?? '') !== 'hmac-sha256' || !isset($parts['v1'])) return false;
  $t = intval($parts['t'] ?? 0);
  if (abs(time() - $t) > 300) return false;
  $mac = hash_hmac('sha256', $t . '.' . $rawBody, $secret);
  return hash_equals($mac, $parts['v1']);
}
```

## Responding to webhooks

- Return **HTTP 200** as soon as you store/queue the event
- Use retries with backoff if your downstream systems are unavailable
- Keep handlers idempotent — process each `event.id` exactly once
